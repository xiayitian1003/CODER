* 术语 “并发”，“并行”，“多任务”，“多处理”，“多线程”，分布式系统（可能还有其他）
  在整个编程文献中都以多种相互冲突的方式使用，并且经常被混为一谈。Brian Goetz 在他 2016 年《从并发到并行》的演讲中指出了这一点，之后提出了合理的二分法：
  >* 并发是关于正确有效地控制对共享资源的访问。 
  >* 并行是使用额外的资源来更快地产生结果。
  
* > 通过并发， 你只能依靠自己，只有知识渊博，保持怀疑和积极进取的人，才能用 Java 编写可靠的 并发代码。

* > ​    但是，并发性通常可以提高在单个处理器上运行的程序的性能。这听起来有点违反直觉。如果考虑一下，由于上下文切换的成本增加（从一个任务更改为另一个任务），在 单个处理器上运行的并发程序实际上应该比程序的所有部分顺序运行具有更多的开销。 在表面上，将程序的所有部分作为单个任务运行并节省上下文切换的成本似乎更便宜。 可以产生影响的问题是阻塞。如果你的程序中的一个任务由于程序控制之外的某
  > ​    些条件（通常是 I/O）而无法继续，我们会说任务或线程阻塞（在我们的科幻故事中， 克隆体已敲门而且是等待它打开）。如果没有并发性，整个程序就会停止，直到外部条 件发生变化。但是，如果使用并发编写程序，则当一个任务被阻止时，程序中的其他任 务可以继续执行，因此程序继续向前移动。实际上，从性能的角度来看，在单处理器机 器上使用并发是没有意义的，除非其中一个任务可能阻塞。

* > 一些编程语言旨在将并发任务彼此隔离。这些通常被称为 _ 函数式语言 _

* > 在经历了多年的 Java 并发之后，我总结了以下四个格言：>1. 不要这样做 > >2. 没有什么是真的，一切可能都有问题 > >3. 它起作用, 并不意味着它没有问题 > >4. 你 仍然必须理解它

* 证明并发性的唯一因素是速度。如果你的程序运行速度不够快 - 在这里要小心，因 为只是希望它运行得更快是不合理的 - 应该首先用一个分析器（参见代码校验章中分析 和优化）来发现你是否可以执行其他一些优化。
## TIJ第四版
* Runnable只是一个普通的接口，只能创建一个待执行的任务，真正将其附在一个新的线程上执行的是Thread
* 