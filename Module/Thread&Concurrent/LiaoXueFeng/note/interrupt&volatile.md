* 为什么要对线程间共享的变量用关键字volatile声明？
  >这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！
* 如果我们去掉`volatile`关键字，运行上述程序，发现效果和带`volatile`差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。
* 这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？
    > 答案是使用守护线程（Daemon Thread）。 
    > 守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。
* 在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。
* 通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。 只有执行线程将锁释放后，其他线程才有机会获得锁并执行。
* 这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。可见，保证一段代码的原子性就是通过加锁和解锁实现的。
* synchronized保证了代码块在任意时刻最多只有一个线程能执行。
* JVM规范定义了几种原子操作：
  > * 基本类型（long和double除外）赋值，例如：int n = m；
  > * 引用类型赋值，例如：List<String> list = anotherList。
* > 多线程同时读写共享变量时，会造成逻辑错误，因此需要通过synchronized同步；
同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；
注意加锁对象必须是同一个实例；
对JVM定义的单个原子操作不需要同步。
* [volatile和synchronized的区别](https://blog.csdn.net/suifeng3051/article/details/52611233)
  > 首先需要理解线程安全的两个方面：执行控制和内存可见。
  > volatile和synchronized的区别
  >* volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
  >* volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
  >* volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
  >* volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
  >* volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
* 大部分类，例如ArrayList，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么ArrayList是可以安全地在线程间共享的。
  * 对同一个线程，能否在获取到锁以后继续获取同一个锁？
  > 答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。
* 不是一个方法中获取了这个对象的锁之后一直抱着这块锁吗，直到运行结束将这块锁释放掉。为什么可重入锁表示这块锁还可以被其他对象使用着，难道这块锁同一时间能被两段不同代码拥有么？望解释。
  > 你理解错了，不是方法获取锁，是线程获取锁。